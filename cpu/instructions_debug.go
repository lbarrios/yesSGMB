package cpu

import (
	"github.com/lbarrios/yesSGMB/types"
)

var instructionsDebug = [0x100]string{
	"nop",            // 0x00
	"ldBcNn",         // 0x01
	"ldMemBcA",       // 0x02
	"incBc",          // 0x03
	"incB",           // 0x04
	"decB",           // 0x05
	"ldBN",           // 0x06
	"rlcA",           // 0x07
	"ldMemNnSp",      // 0x08
	"addHlBc",        // 0x09
	"ldAMemBc",       // 0x0A
	"decBc",          // 0x0B
	"incC",           // 0x0C
	"decC",           // 0x0D
	"ldCN",           // 0x0E
	"rrcA",           // 0x0F
	"stop",           // 0x10
	"ldDeNn",         // 0x11
	"ldMemDeA",       // 0x12
	"incDe",          // 0x13
	"incD",           // 0x14
	"decD",           // 0x15
	"ldDN",           // 0x16
	"rlA",            // 0x17
	"jr",             // 0x18
	"addHlDe",        // 0x19
	"ldAMemDe",       // 0x1A
	"decDe",          // 0x1B
	"incE",           // 0x1C
	"decE",           // 0x1D
	"ldEN",           // 0x1E
	"rrA",            // 0x1F
	"jrNZ",           // 0x20
	"ldHlNn",         // 0x21
	"ldiMemHlA",      // 0x22
	"incHl",          // 0x23
	"incH",           // 0x24
	"decH",           // 0x25
	"ldHN",           // 0x26
	"daA",            // 0x27
	"jrZ",            // 0x28
	"addHlHl",        // 0x29
	"ldiAMemHl",      // 0x2A
	"decHl",          // 0x2B
	"incL",           // 0x2C
	"decL",           // 0x2D
	"ldLN",           // 0x2E
	"cplA",           // 0x2F
	"jrNC",           // 0x30
	"ldSpNn",         // 0x31
	"lddMemHlA",      // 0x32
	"incSp",          // 0x33
	"incMemHl",       // 0x34
	"decMemHl",       // 0x35
	"ldMemHlN",       // 0x36
	"scf",            // 0x37
	"jrC",            // 0x38
	"addHlSp",        // 0x39
	"lddAMemHl",      // 0x3A
	"decSp",          // 0x3B
	"incA",           // 0x3C
	"decA",           // 0x3D
	"ldAN",           // 0x3E
	"ccf",            // 0x3F
	"ldBB",           // 0x40
	"ldBC",           // 0x41
	"ldBD",           // 0x42
	"ldBE",           // 0x43
	"ldBH",           // 0x44
	"ldBL",           // 0x45
	"ldBHl",          // 0x46
	"ldBA",           // 0x47
	"ldCB",           // 0x48
	"ldCC",           // 0x49
	"ldCD",           // 0x4A
	"ldCE",           // 0x4B
	"ldCH",           // 0x4C
	"ldCL",           // 0x4D
	"ldCHl",          // 0x4E
	"ldCA",           // 0x4F
	"ldDB",           // 0x50
	"ldDC",           // 0x51
	"ldDD",           // 0x52
	"ldDE",           // 0x53
	"ldDH",           // 0x54
	"ldDL",           // 0x55
	"ldDHl",          // 0x56
	"ldDA",           // 0x57
	"ldEB",           // 0x58
	"ldEC",           // 0x59
	"ldED",           // 0x5A
	"ldEE",           // 0x5B
	"ldEH",           // 0x5C
	"ldEL",           // 0x5D
	"ldEHl",          // 0x5E
	"ldEA",           // 0x5F
	"ldHB",           // 0x60
	"ldHC",           // 0x61
	"ldHD",           // 0x62
	"ldHE",           // 0x63
	"ldHH",           // 0x64
	"ldHL",           // 0x65
	"ldHMemHl",       // 0x66
	"ldHA",           // 0x67
	"ldLB",           // 0x68
	"ldLC",           // 0x69
	"ldLD",           // 0x6A
	"ldLE",           // 0x6B
	"ldLH",           // 0x6C
	"ldLL",           // 0x6D
	"ldLHl",          // 0x6E
	"ldLA",           // 0x6F
	"ldMemHlB",       // 0x70
	"ldMemHlC",       // 0x71
	"ldMemHlD",       // 0x72
	"ldMemHlE",       // 0x73
	"ldMemHlL",       // 0x74
	"ldMemHlH",       // 0x75
	"halt",           // 0x76
	"ldMemHlA",       // 0x77
	"ldAB",           // 0x78
	"ldAC",           // 0x79
	"ldAD",           // 0x7A
	"ldAE",           // 0x7B
	"ldAH",           // 0x7C
	"ldAL",           // 0x7D
	"ldAMemHl",       // 0x7E
	"ldAA",           // 0x7F
	"addAB",          // 0x80
	"addAC",          // 0x81
	"addAD",          // 0x82
	"addAE",          // 0x83
	"addAH",          // 0x84
	"addAL",          // 0x85
	"addAMemHl",      // 0x86
	"addAA",          // 0x87
	"adcAB",          // 0x88
	"adcAC",          // 0x89
	"adcAD",          // 0x8A
	"adcAE",          // 0x8B
	"adcAH",          // 0x8C
	"adcAL",          // 0x8D
	"adcAMemHl",      // 0x8E
	"adcAA",          // 0x8F
	"subAB",          // 0x90
	"subAC",          // 0x91
	"subAD",          // 0x92
	"subAE",          // 0x93
	"subAH",          // 0x94
	"subAL",          // 0x95
	"subAMemHl",      // 0x96
	"subAA",          // 0x97
	"sbcAB",          // 0x98
	"sbcAC",          // 0x99
	"sbcAD",          // 0x9A
	"sbcAE",          // 0x9B
	"sbcAH",          // 0x9C
	"sbcAL",          // 0x9D
	"sbcAMemHl",      // 0x9E
	"sbcAA",          // 0x9F
	"andAB",          // 0xA0
	"andAC",          // 0xA1
	"andAD",          // 0xA2
	"andAE",          // 0xA3
	"andAH",          // 0xA4
	"andAL",          // 0xA5
	"andAMemHl",      // 0xA6
	"andAA",          // 0xA7
	"xorAB",          // 0xA8
	"xorAC",          // 0xA9
	"xorAD",          // 0xAA
	"xorAE",          // 0xAB
	"xorAH",          // 0xAC
	"xorAL",          // 0xAD
	"xorAMemHl",      // 0xAE
	"xorAA",          // 0xAF
	"orAB",           // 0xB0
	"orAC",           // 0xB1
	"orAD",           // 0xB2
	"orAE",           // 0xB3
	"orAH",           // 0xB4
	"orAL",           // 0xB5
	"orAMemHl",       // 0xB6
	"orAA",           // 0xB7
	"cpAB",           // 0xB8
	"cpAC",           // 0xB9
	"cpAD",           // 0xBA
	"cpAE",           // 0xBB
	"cpAH",           // 0xBC
	"cpAL",           // 0xBD
	"cpAMemHl",       // 0xBE
	"cpAA",           // 0xBF
	"retNZ",          // 0xC0
	"popBc",          // 0xC1
	"jpNZ",           // 0xC2
	"jp",             // 0xC3
	"callNZ",         // 0xC4
	"pushBc",         // 0xC5
	"addAN",          // 0xC6
	"rst00H",         // 0xC7
	"retZ",           // 0xC8
	"ret",            // 0xC9
	"jpZ",            // 0xCA
	"rxN",            // 0xCB
	"callZ",          // 0xCC
	"call",           // 0xCD
	"adcANn",         // 0xCE
	"rst08H",         // 0xCF
	"retNC",          // 0xD0
	"popDe",          // 0xD1
	"jpNC",           // 0xD2
	"nonImplemented", // 0xD3
	"callNC",         // 0xD4
	"pushDe",         // 0xD5
	"subAN",          // 0xD6
	"rst10H",         // 0xD7
	"retC",           // 0xD8
	"reti",           // 0xD9
	"jpC",            // 0xDA
	"nonImplemented", // 0xDB
	"callC",          // 0xDC
	"nonImplemented", // 0xDD
	"sbcAN",          // 0xDE
	"rst18H",         // 0xDF
	"ldStackNA",      // 0xE0
	"popHl",          // 0xE1
	"ldStackCA",      // 0xE2
	"nonImplemented", // 0xE3
	"nonImplemented", // 0xE4
	"pushHl",         // 0xE5
	"andAN",          // 0xE6
	"rst20H",         // 0xE7
	"addSpN",         // 0xE8
	"jpHl",           // 0xE9
	"ldMemNnA",       // 0xEA
	"nonImplemented", // 0xEB
	"nonImplemented", // 0xEC
	"nonImplemented", // 0xED
	"xorAN",          // 0xEE
	"rst28H",         // 0xEF
	"ldAStackN",      // 0xF0
	"popAf",          // 0xF1
	"ldAStackC",      // 0xF2
	"di",             // 0xF3
	"nonImplemented", // 0xF4
	"pushAf",         // 0xF5
	"orAN",           // 0xF6
	"rst30H",         // 0xF7
	"ldHlSpN",        // 0xF8
	"ldSpHl",         // 0xF9
	"ldAMemNn",       // 0xFA
	"ei",             // 0xFB
	"nonImplemented", // 0xFC
	"nonImplemented", // 0xFD
	"cpAN",           // 0xFE
	"rst38H",         // 0xFF
}

var operationsDebug = [0x100]instruction{
	nop,            // 0x00
	ldBcNn,         // 0x01
	ldMemBcA,       // 0x02
	incBc,          // 0x03
	incB,           // 0x04
	decB,           // 0x05
	ldBN,           // 0x06
	rlcA,           // 0x07
	ldMemNnSp,      // 0x08
	addHlBc,        // 0x09
	ldAMemBc,       // 0x0A
	decBc,          // 0x0B
	incC,           // 0x0C
	decC,           // 0x0D
	ldCN,           // 0x0E
	rrcA,           // 0x0F
	stop,           // 0x10
	ldDeNn,         // 0x11
	ldMemDeA,       // 0x12
	incDe,          // 0x13
	incD,           // 0x14
	decD,           // 0x15
	ldDN,           // 0x16
	rlA,            // 0x17
	jr,             // 0x18
	addHlDe,        // 0x19
	ldAMemDe,       // 0x1A
	decDe,          // 0x1B
	incE,           // 0x1C
	decE,           // 0x1D
	ldEN,           // 0x1E
	rrA,            // 0x1F
	jrNZ,           // 0x20
	ldHlNn,         // 0x21
	ldiMemHlA,      // 0x22
	incHl,          // 0x23
	incH,           // 0x24
	decH,           // 0x25
	ldHN,           // 0x26
	daA,            // 0x27
	jrZ,            // 0x28
	addHlHl,        // 0x29
	ldiAMemHlDebug, // 0x2A
	decHl,          // 0x2B
	incL,           // 0x2C
	decL,           // 0x2D
	ldLN,           // 0x2E
	cplA,           // 0x2F
	jrNC,           // 0x30
	ldSpNnDebug,    // 0x31
	lddMemHlA,      // 0x32
	incSp,          // 0x33
	incMemHl,       // 0x34
	decMemHl,       // 0x35
	ldMemHlN,       // 0x36
	scf,            // 0x37
	jrC,            // 0x38
	addHlSp,        // 0x39
	lddAMemHl,      // 0x3A
	decSp,          // 0x3B
	incA,           // 0x3C
	decA,           // 0x3D
	ldAN,           // 0x3E
	ccf,            // 0x3F
	ldBB,           // 0x40
	ldBC,           // 0x41
	ldBD,           // 0x42
	ldBE,           // 0x43
	ldBH,           // 0x44
	ldBL,           // 0x45
	ldBHl,          // 0x46
	ldBA,           // 0x47
	ldCB,           // 0x48
	ldCC,           // 0x49
	ldCD,           // 0x4A
	ldCE,           // 0x4B
	ldCH,           // 0x4C
	ldCL,           // 0x4D
	ldCHl,          // 0x4E
	ldCA,           // 0x4F
	ldDB,           // 0x50
	ldDC,           // 0x51
	ldDD,           // 0x52
	ldDE,           // 0x53
	ldDH,           // 0x54
	ldDL,           // 0x55
	ldDHl,          // 0x56
	ldDA,           // 0x57
	ldEB,           // 0x58
	ldEC,           // 0x59
	ldED,           // 0x5A
	ldEE,           // 0x5B
	ldEH,           // 0x5C
	ldEL,           // 0x5D
	ldEHl,          // 0x5E
	ldEA,           // 0x5F
	ldHB,           // 0x60
	ldHC,           // 0x61
	ldHD,           // 0x62
	ldHE,           // 0x63
	ldHH,           // 0x64
	ldHL,           // 0x65
	ldHMemHl,       // 0x66
	ldHA,           // 0x67
	ldLB,           // 0x68
	ldLC,           // 0x69
	ldLD,           // 0x6A
	ldLE,           // 0x6B
	ldLH,           // 0x6C
	ldLL,           // 0x6D
	ldLHl,          // 0x6E
	ldLA,           // 0x6F
	ldMemHlB,       // 0x70
	ldMemHlC,       // 0x71
	ldMemHlD,       // 0x72
	ldMemHlE,       // 0x73
	ldMemHlL,       // 0x74
	ldMemHlH,       // 0x75
	halt,           // 0x76
	ldMemHlA,       // 0x77
	ldAB,           // 0x78
	ldAC,           // 0x79
	ldAD,           // 0x7A
	ldAE,           // 0x7B
	ldAH,           // 0x7C
	ldAL,           // 0x7D
	ldAMemHl,       // 0x7E
	ldAA,           // 0x7F
	addAB,          // 0x80
	addAC,          // 0x81
	addAD,          // 0x82
	addAE,          // 0x83
	addAH,          // 0x84
	addAL,          // 0x85
	addAMemHl,      // 0x86
	addAA,          // 0x87
	adcAB,          // 0x88
	adcAC,          // 0x89
	adcAD,          // 0x8A
	adcAE,          // 0x8B
	adcAH,          // 0x8C
	adcAL,          // 0x8D
	adcAMemHl,      // 0x8E
	adcAA,          // 0x8F
	subAB,          // 0x90
	subAC,          // 0x91
	subAD,          // 0x92
	subAE,          // 0x93
	subAH,          // 0x94
	subAL,          // 0x95
	subAMemHl,      // 0x96
	subAA,          // 0x97
	sbcAB,          // 0x98
	sbcAC,          // 0x99
	sbcAD,          // 0x9A
	sbcAE,          // 0x9B
	sbcAH,          // 0x9C
	sbcAL,          // 0x9D
	sbcAMemHl,      // 0x9E
	sbcAA,          // 0x9F
	andAB,          // 0xA0
	andAC,          // 0xA1
	andAD,          // 0xA2
	andAE,          // 0xA3
	andAH,          // 0xA4
	andAL,          // 0xA5
	andAMemHl,      // 0xA6
	andAA,          // 0xA7
	xorAB,          // 0xA8
	xorAC,          // 0xA9
	xorAD,          // 0xAA
	xorAE,          // 0xAB
	xorAH,          // 0xAC
	xorAL,          // 0xAD
	xorAMemHl,      // 0xAE
	xorAA,          // 0xAF
	orAB,           // 0xB0
	orAC,           // 0xB1
	orAD,           // 0xB2
	orAE,           // 0xB3
	orAH,           // 0xB4
	orAL,           // 0xB5
	orAMemHl,       // 0xB6
	orAA,           // 0xB7
	cpAB,           // 0xB8
	cpAC,           // 0xB9
	cpAD,           // 0xBA
	cpAE,           // 0xBB
	cpAH,           // 0xBC
	cpAL,           // 0xBD
	cpAMemHl,       // 0xBE
	cpAA,           // 0xBF
	retNZ,          // 0xC0
	popBc,          // 0xC1
	jpNZ,           // 0xC2
	jp,             // 0xC3
	callNZ,         // 0xC4
	pushBc,         // 0xC5
	addAN,          // 0xC6
	rst00H,         // 0xC7
	retZ,           // 0xC8
	ret,            // 0xC9
	jpZ,            // 0xCA
	rxN,            // 0xCB
	callZ,          // 0xCC
	callDebug,      // 0xCD
	adcANn,         // 0xCE
	rst08H,         // 0xCF
	retNC,          // 0xD0
	popDe,          // 0xD1
	jpNC,           // 0xD2
	nonImplemented, // 0xD3
	callNC,         // 0xD4
	pushDe,         // 0xD5
	subAN,          // 0xD6
	rst10H,         // 0xD7
	retC,           // 0xD8
	reti,           // 0xD9
	jpC,            // 0xDA
	nonImplemented, // 0xDB
	callC,          // 0xDC
	nonImplemented, // 0xDD
	sbcAN,          // 0xDE
	rst18H,         // 0xDF
	ldStackNA,      // 0xE0
	popHl,          // 0xE1
	ldStackCA,      // 0xE2
	nonImplemented, // 0xE3
	nonImplemented, // 0xE4
	pushHl,         // 0xE5
	andAN,          // 0xE6
	rst20H,         // 0xE7
	addSpN,         // 0xE8
	jpHl,           // 0xE9
	ldMemNnA,       // 0xEA
	nonImplemented, // 0xEB
	nonImplemented, // 0xEC
	nonImplemented, // 0xED
	xorAN,          // 0xEE
	rst28H,         // 0xEF
	ldAStackNDebug, // 0xF0
	popAf,          // 0xF1
	ldAStackC,      // 0xF2
	di,             // 0xF3
	nonImplemented, // 0xF4
	pushAf,         // 0xF5
	orAN,           // 0xF6
	rst30H,         // 0xF7
	ldHlSpN,        // 0xF8
	ldSpHl,         // 0xF9
	ldAMemNn,       // 0xFA
	ei,             // 0xFB
	nonImplemented, // 0xFC
	nonImplemented, // 0xFD
	cpANDebug,      // 0xFE
	rst38H,         // 0xFF
}

func cpANDebug(cpu *cpu) cycleCount {
	// Compares A to #. The result is not stored; this function only affects flags.
	n := cpu.fetch()
	cpu.log.Printf("fetching parameter N = %.2x", n)
	cpu.r.setFlagZ(cpu.r.af.a == n)
	cpu.r.setFlagN(true)
	cpu.r.setFlagH((cpu.r.af.a >> 4) < (n >> 4))
	cpu.r.setFlagC(cpu.r.af.a < n)
	return cpANCycles
}

func ldAStackNDebug(cpu *cpu) cycleCount {
	// Takes from the stack the value indexed by the immediate value N, and put it into register A.
	n := cpu.fetch()
	cpu.r.af.a = cpu.mmu.ReadByte(types.Address{High: 0xFF, Low: n})
	cpu.log.Printf("fetching parameter N = %.2x, reading address 0x%.2x%.2x = %.2x", n, 0xFF, n, cpu.r.af.a)
	return ldAStackNCycles
}

func ldiAMemHlDebug(cpu *cpu) cycleCount {
	// Put the value from the position of memory pointed by HL into the register A.
	// Then, increment  HL.
	cpu.r.af.a = cpu.mmu.ReadByte(cpu.r.hlAsAddress())
	cpu.log.Printf("fetching parameter (HL) = (0x%.4x) = 0x%.2x", cpu.r.hlAsAddress().AsWord(), cpu.r.af.a)
	hl := cpu.r.hlAsWord() + 0x0001
	cpu.r.hl.h = hl.High()
	cpu.r.hl.l = hl.Low()
	cpu.log.Printf("incrementing hl, newhl=0x%.4x, newh=0x%.2x, newl=0x%.2x", hl, cpu.r.hl.h, cpu.r.hl.l)
	return ldiAMemHlCycles
}

func callDebug(cpu *cpu) cycleCount {
	// Push the address of the next instruction onto stack
	// and jump to address nn
	// (nn: parameter from immediate value)
	low := cpu.fetch()
	cpu.log.Printf("fetching parameter l=0x%.2x, pc=0x%.2x", low, cpu.r.pc)
	high := cpu.fetch()
	cpu.log.Printf("fetching parameter h=0x%.2x, pc=0x%.2x", high, cpu.r.pc)
	cpu.r.sp--
	cpu.mmu.WriteByte(cpu.r.spAsAddress(), cpu.r.pc.High())
	cpu.r.sp--
	cpu.mmu.WriteByte(cpu.r.spAsAddress(), cpu.r.pc.Low())
	cpu.r.pc = types.Address{High:high, Low:low}.AsWord()
	return callCycles
}

func ldSpNnDebug(cpu *cpu) cycleCount {
	// Takes a 16-bit immediate value and put it into the register SP.
	// (LS byte comes first!)
	low := cpu.fetch()
	high := cpu.fetch()
	cpu.r.sp = types.Address{High: high, Low: low}.AsWord()
	return ldSpNnCycles
}
